// This file is auto generated by the protocol-buffers compiler

/* eslint-disable quotes */
/* eslint-disable indent */
/* eslint-disable no-redeclare */
/* eslint-disable camelcase */

// Remember to `npm install --save protocol-buffers-encodings`
var encodings = require('protocol-buffers-encodings')
var varint = encodings.varint
var skip = encodings.skip

var MetadbMessage = exports.MetadbMessage = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var AddFile = exports.AddFile = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var RmFiles = exports.RmFiles = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var About = exports.About = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var FileComment = exports.FileComment = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var Header = exports.Header = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var Private = exports.Private = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var WallMessage = exports.WallMessage = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var Invite = exports.Invite = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

defineMetadbMessage()
defineAddFile()
defineRmFiles()
defineAbout()
defineFileComment()
defineHeader()
definePrivate()
defineWallMessage()
defineInvite()

function defineMetadbMessage () {
  MetadbMessage.encodingLength = encodingLength
  MetadbMessage.encode = encode
  MetadbMessage.decode = decode

  function encodingLength (obj) {
    var length = 0
    if ((+defined(obj.addFile) + +defined(obj.fileComment) + +defined(obj.rmFiles) + +defined(obj.invite) + +defined(obj.about) + +defined(obj.header) + +defined(obj.wallMessage) + +defined(obj.private)) > 1) throw new Error("only one of the properties defined in oneof msg can be set")
    if (defined(obj.timestamp)) {
      var len = encodings.int64.encodingLength(obj.timestamp)
      length += 1 + len
    }
    if (defined(obj.addFile)) {
      var len = AddFile.encodingLength(obj.addFile)
      length += varint.encodingLength(len)
      length += 1 + len
    }
    if (defined(obj.fileComment)) {
      var len = FileComment.encodingLength(obj.fileComment)
      length += varint.encodingLength(len)
      length += 1 + len
    }
    if (defined(obj.rmFiles)) {
      var len = RmFiles.encodingLength(obj.rmFiles)
      length += varint.encodingLength(len)
      length += 1 + len
    }
    if (defined(obj.invite)) {
      var len = Invite.encodingLength(obj.invite)
      length += varint.encodingLength(len)
      length += 1 + len
    }
    if (defined(obj.about)) {
      var len = About.encodingLength(obj.about)
      length += varint.encodingLength(len)
      length += 1 + len
    }
    if (defined(obj.header)) {
      var len = Header.encodingLength(obj.header)
      length += varint.encodingLength(len)
      length += 1 + len
    }
    if (defined(obj.wallMessage)) {
      var len = WallMessage.encodingLength(obj.wallMessage)
      length += varint.encodingLength(len)
      length += 1 + len
    }
    if (defined(obj.private)) {
      var len = Private.encodingLength(obj.private)
      length += varint.encodingLength(len)
      length += 1 + len
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if ((+defined(obj.addFile) + +defined(obj.fileComment) + +defined(obj.rmFiles) + +defined(obj.invite) + +defined(obj.about) + +defined(obj.header) + +defined(obj.wallMessage) + +defined(obj.private)) > 1) throw new Error("only one of the properties defined in oneof msg can be set")
    if (defined(obj.timestamp)) {
      buf[offset++] = 8
      encodings.int64.encode(obj.timestamp, buf, offset)
      offset += encodings.int64.encode.bytes
    }
    if (defined(obj.addFile)) {
      buf[offset++] = 18
      varint.encode(AddFile.encodingLength(obj.addFile), buf, offset)
      offset += varint.encode.bytes
      AddFile.encode(obj.addFile, buf, offset)
      offset += AddFile.encode.bytes
    }
    if (defined(obj.fileComment)) {
      buf[offset++] = 26
      varint.encode(FileComment.encodingLength(obj.fileComment), buf, offset)
      offset += varint.encode.bytes
      FileComment.encode(obj.fileComment, buf, offset)
      offset += FileComment.encode.bytes
    }
    if (defined(obj.rmFiles)) {
      buf[offset++] = 34
      varint.encode(RmFiles.encodingLength(obj.rmFiles), buf, offset)
      offset += varint.encode.bytes
      RmFiles.encode(obj.rmFiles, buf, offset)
      offset += RmFiles.encode.bytes
    }
    if (defined(obj.invite)) {
      buf[offset++] = 42
      varint.encode(Invite.encodingLength(obj.invite), buf, offset)
      offset += varint.encode.bytes
      Invite.encode(obj.invite, buf, offset)
      offset += Invite.encode.bytes
    }
    if (defined(obj.about)) {
      buf[offset++] = 50
      varint.encode(About.encodingLength(obj.about), buf, offset)
      offset += varint.encode.bytes
      About.encode(obj.about, buf, offset)
      offset += About.encode.bytes
    }
    if (defined(obj.header)) {
      buf[offset++] = 58
      varint.encode(Header.encodingLength(obj.header), buf, offset)
      offset += varint.encode.bytes
      Header.encode(obj.header, buf, offset)
      offset += Header.encode.bytes
    }
    if (defined(obj.wallMessage)) {
      buf[offset++] = 66
      varint.encode(WallMessage.encodingLength(obj.wallMessage), buf, offset)
      offset += varint.encode.bytes
      WallMessage.encode(obj.wallMessage, buf, offset)
      offset += WallMessage.encode.bytes
    }
    if (defined(obj.private)) {
      buf[offset++] = 74
      varint.encode(Private.encodingLength(obj.private), buf, offset)
      offset += varint.encode.bytes
      Private.encode(obj.private, buf, offset)
      offset += Private.encode.bytes
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      timestamp: 0,
      addFile: null,
      fileComment: null,
      rmFiles: null,
      invite: null,
      about: null,
      header: null,
      wallMessage: null,
      private: null
    }
    while (true) {
      if (end <= offset) {
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.timestamp = encodings.int64.decode(buf, offset)
        offset += encodings.int64.decode.bytes
        break
        case 2:
        delete obj.fileComment
        delete obj.rmFiles
        delete obj.invite
        delete obj.about
        delete obj.header
        delete obj.wallMessage
        delete obj.private
        var len = varint.decode(buf, offset)
        offset += varint.decode.bytes
        obj.addFile = AddFile.decode(buf, offset, offset + len)
        offset += AddFile.decode.bytes
        break
        case 3:
        delete obj.addFile
        delete obj.rmFiles
        delete obj.invite
        delete obj.about
        delete obj.header
        delete obj.wallMessage
        delete obj.private
        var len = varint.decode(buf, offset)
        offset += varint.decode.bytes
        obj.fileComment = FileComment.decode(buf, offset, offset + len)
        offset += FileComment.decode.bytes
        break
        case 4:
        delete obj.addFile
        delete obj.fileComment
        delete obj.invite
        delete obj.about
        delete obj.header
        delete obj.wallMessage
        delete obj.private
        var len = varint.decode(buf, offset)
        offset += varint.decode.bytes
        obj.rmFiles = RmFiles.decode(buf, offset, offset + len)
        offset += RmFiles.decode.bytes
        break
        case 5:
        delete obj.addFile
        delete obj.fileComment
        delete obj.rmFiles
        delete obj.about
        delete obj.header
        delete obj.wallMessage
        delete obj.private
        var len = varint.decode(buf, offset)
        offset += varint.decode.bytes
        obj.invite = Invite.decode(buf, offset, offset + len)
        offset += Invite.decode.bytes
        break
        case 6:
        delete obj.addFile
        delete obj.fileComment
        delete obj.rmFiles
        delete obj.invite
        delete obj.header
        delete obj.wallMessage
        delete obj.private
        var len = varint.decode(buf, offset)
        offset += varint.decode.bytes
        obj.about = About.decode(buf, offset, offset + len)
        offset += About.decode.bytes
        break
        case 7:
        delete obj.addFile
        delete obj.fileComment
        delete obj.rmFiles
        delete obj.invite
        delete obj.about
        delete obj.wallMessage
        delete obj.private
        var len = varint.decode(buf, offset)
        offset += varint.decode.bytes
        obj.header = Header.decode(buf, offset, offset + len)
        offset += Header.decode.bytes
        break
        case 8:
        delete obj.addFile
        delete obj.fileComment
        delete obj.rmFiles
        delete obj.invite
        delete obj.about
        delete obj.header
        delete obj.private
        var len = varint.decode(buf, offset)
        offset += varint.decode.bytes
        obj.wallMessage = WallMessage.decode(buf, offset, offset + len)
        offset += WallMessage.decode.bytes
        break
        case 9:
        delete obj.addFile
        delete obj.fileComment
        delete obj.rmFiles
        delete obj.invite
        delete obj.about
        delete obj.header
        delete obj.wallMessage
        var len = varint.decode(buf, offset)
        offset += varint.decode.bytes
        obj.private = Private.decode(buf, offset, offset + len)
        offset += Private.decode.bytes
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineAddFile () {
  AddFile.encodingLength = encodingLength
  AddFile.encode = encode
  AddFile.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (defined(obj.sha256)) {
      var len = encodings.bytes.encodingLength(obj.sha256)
      length += 1 + len
    }
    if (!defined(obj.filename)) throw new Error("filename is required")
    var len = encodings.string.encodingLength(obj.filename)
    length += 1 + len
    if (defined(obj.size)) {
      var len = encodings.int64.encodingLength(obj.size)
      length += 1 + len
    }
    if (defined(obj.metadata)) {
      var len = encodings.string.encodingLength(obj.metadata)
      length += 1 + len
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (defined(obj.sha256)) {
      buf[offset++] = 10
      encodings.bytes.encode(obj.sha256, buf, offset)
      offset += encodings.bytes.encode.bytes
    }
    if (!defined(obj.filename)) throw new Error("filename is required")
    buf[offset++] = 18
    encodings.string.encode(obj.filename, buf, offset)
    offset += encodings.string.encode.bytes
    if (defined(obj.size)) {
      buf[offset++] = 24
      encodings.int64.encode(obj.size, buf, offset)
      offset += encodings.int64.encode.bytes
    }
    if (defined(obj.metadata)) {
      buf[offset++] = 34
      encodings.string.encode(obj.metadata, buf, offset)
      offset += encodings.string.encode.bytes
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      sha256: null,
      filename: "",
      size: 0,
      metadata: ""
    }
    var found1 = false
    while (true) {
      if (end <= offset) {
        if (!found1) throw new Error("Decoded message is not valid")
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.sha256 = encodings.bytes.decode(buf, offset)
        offset += encodings.bytes.decode.bytes
        break
        case 2:
        obj.filename = encodings.string.decode(buf, offset)
        offset += encodings.string.decode.bytes
        found1 = true
        break
        case 3:
        obj.size = encodings.int64.decode(buf, offset)
        offset += encodings.int64.decode.bytes
        break
        case 4:
        obj.metadata = encodings.string.decode(buf, offset)
        offset += encodings.string.decode.bytes
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineRmFiles () {
  RmFiles.encodingLength = encodingLength
  RmFiles.encode = encode
  RmFiles.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (defined(obj.files)) {
      for (var i = 0; i < obj.files.length; i++) {
        if (!defined(obj.files[i])) continue
        var len = encodings.bytes.encodingLength(obj.files[i])
        length += 1 + len
      }
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (defined(obj.files)) {
      for (var i = 0; i < obj.files.length; i++) {
        if (!defined(obj.files[i])) continue
        buf[offset++] = 10
        encodings.bytes.encode(obj.files[i], buf, offset)
        offset += encodings.bytes.encode.bytes
      }
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      files: []
    }
    while (true) {
      if (end <= offset) {
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.files.push(encodings.bytes.decode(buf, offset))
        offset += encodings.bytes.decode.bytes
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineAbout () {
  About.encodingLength = encodingLength
  About.encode = encode
  About.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (defined(obj.name)) {
      var len = encodings.string.encodingLength(obj.name)
      length += 1 + len
    }
    if (defined(obj.profile)) {
      var len = encodings.string.encodingLength(obj.profile)
      length += 1 + len
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (defined(obj.name)) {
      buf[offset++] = 10
      encodings.string.encode(obj.name, buf, offset)
      offset += encodings.string.encode.bytes
    }
    if (defined(obj.profile)) {
      buf[offset++] = 18
      encodings.string.encode(obj.profile, buf, offset)
      offset += encodings.string.encode.bytes
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      name: "",
      profile: ""
    }
    while (true) {
      if (end <= offset) {
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.name = encodings.string.decode(buf, offset)
        offset += encodings.string.decode.bytes
        break
        case 2:
        obj.profile = encodings.string.decode(buf, offset)
        offset += encodings.string.decode.bytes
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineFileComment () {
  FileComment.encodingLength = encodingLength
  FileComment.encode = encode
  FileComment.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (defined(obj.sha256)) {
      var len = encodings.bytes.encodingLength(obj.sha256)
      length += 1 + len
    }
    if (defined(obj.comment)) {
      var len = encodings.string.encodingLength(obj.comment)
      length += 1 + len
    }
    if (defined(obj.star)) {
      var len = encodings.bool.encodingLength(obj.star)
      length += 1 + len
    }
    if (defined(obj.unstar)) {
      var len = encodings.bool.encodingLength(obj.unstar)
      length += 1 + len
    }
    if (defined(obj.extras)) {
      var len = encodings.string.encodingLength(obj.extras)
      length += 1 + len
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (defined(obj.sha256)) {
      buf[offset++] = 10
      encodings.bytes.encode(obj.sha256, buf, offset)
      offset += encodings.bytes.encode.bytes
    }
    if (defined(obj.comment)) {
      buf[offset++] = 18
      encodings.string.encode(obj.comment, buf, offset)
      offset += encodings.string.encode.bytes
    }
    if (defined(obj.star)) {
      buf[offset++] = 24
      encodings.bool.encode(obj.star, buf, offset)
      offset += encodings.bool.encode.bytes
    }
    if (defined(obj.unstar)) {
      buf[offset++] = 32
      encodings.bool.encode(obj.unstar, buf, offset)
      offset += encodings.bool.encode.bytes
    }
    if (defined(obj.extras)) {
      buf[offset++] = 42
      encodings.string.encode(obj.extras, buf, offset)
      offset += encodings.string.encode.bytes
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      sha256: null,
      comment: "",
      star: false,
      unstar: false,
      extras: ""
    }
    while (true) {
      if (end <= offset) {
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.sha256 = encodings.bytes.decode(buf, offset)
        offset += encodings.bytes.decode.bytes
        break
        case 2:
        obj.comment = encodings.string.decode(buf, offset)
        offset += encodings.string.decode.bytes
        break
        case 3:
        obj.star = encodings.bool.decode(buf, offset)
        offset += encodings.bool.decode.bytes
        break
        case 4:
        obj.unstar = encodings.bool.decode(buf, offset)
        offset += encodings.bool.decode.bytes
        break
        case 5:
        obj.extras = encodings.string.decode(buf, offset)
        offset += encodings.string.decode.bytes
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineHeader () {
  Header.encodingLength = encodingLength
  Header.encode = encode
  Header.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (!defined(obj.type)) throw new Error("type is required")
    var len = encodings.string.encodingLength(obj.type)
    length += 1 + len
    if (defined(obj.metadata)) {
      var len = encodings.bytes.encodingLength(obj.metadata)
      length += 1 + len
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (!defined(obj.type)) throw new Error("type is required")
    buf[offset++] = 10
    encodings.string.encode(obj.type, buf, offset)
    offset += encodings.string.encode.bytes
    if (defined(obj.metadata)) {
      buf[offset++] = 18
      encodings.bytes.encode(obj.metadata, buf, offset)
      offset += encodings.bytes.encode.bytes
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      type: "",
      metadata: null
    }
    var found0 = false
    while (true) {
      if (end <= offset) {
        if (!found0) throw new Error("Decoded message is not valid")
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.type = encodings.string.decode(buf, offset)
        offset += encodings.string.decode.bytes
        found0 = true
        break
        case 2:
        obj.metadata = encodings.bytes.decode(buf, offset)
        offset += encodings.bytes.decode.bytes
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function definePrivate () {
  Private.encodingLength = encodingLength
  Private.encode = encode
  Private.decode = decode

  function encodingLength (obj) {
    var length = 0
    if ((+defined(obj.asymmetric) + +defined(obj.symmetric)) > 1) throw new Error("only one of the properties defined in oneof ciphertext can be set")
    if (defined(obj.asymmetric)) {
      var len = encodings.bytes.encodingLength(obj.asymmetric)
      length += 1 + len
    }
    if (defined(obj.symmetric)) {
      var len = encodings.bytes.encodingLength(obj.symmetric)
      length += 1 + len
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if ((+defined(obj.asymmetric) + +defined(obj.symmetric)) > 1) throw new Error("only one of the properties defined in oneof ciphertext can be set")
    if (defined(obj.asymmetric)) {
      buf[offset++] = 10
      encodings.bytes.encode(obj.asymmetric, buf, offset)
      offset += encodings.bytes.encode.bytes
    }
    if (defined(obj.symmetric)) {
      buf[offset++] = 18
      encodings.bytes.encode(obj.symmetric, buf, offset)
      offset += encodings.bytes.encode.bytes
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      asymmetric: null,
      symmetric: null
    }
    while (true) {
      if (end <= offset) {
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        delete obj.symmetric
        obj.asymmetric = encodings.bytes.decode(buf, offset)
        offset += encodings.bytes.decode.bytes
        break
        case 2:
        delete obj.asymmetric
        obj.symmetric = encodings.bytes.decode(buf, offset)
        offset += encodings.bytes.decode.bytes
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineWallMessage () {
  WallMessage.encodingLength = encodingLength
  WallMessage.encode = encode
  WallMessage.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (defined(obj.message)) {
      var len = encodings.string.encodingLength(obj.message)
      length += 1 + len
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (defined(obj.message)) {
      buf[offset++] = 10
      encodings.string.encode(obj.message, buf, offset)
      offset += encodings.string.encode.bytes
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      message: ""
    }
    while (true) {
      if (end <= offset) {
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.message = encodings.string.decode(buf, offset)
        offset += encodings.string.decode.bytes
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineInvite () {
  Invite.encodingLength = encodingLength
  Invite.encode = encode
  Invite.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (defined(obj.link)) {
      var len = encodings.bytes.encodingLength(obj.link)
      length += 1 + len
    }
    if (defined(obj.comment)) {
      var len = encodings.string.encodingLength(obj.comment)
      length += 1 + len
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (defined(obj.link)) {
      buf[offset++] = 10
      encodings.bytes.encode(obj.link, buf, offset)
      offset += encodings.bytes.encode.bytes
    }
    if (defined(obj.comment)) {
      buf[offset++] = 18
      encodings.string.encode(obj.comment, buf, offset)
      offset += encodings.string.encode.bytes
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      link: null,
      comment: ""
    }
    while (true) {
      if (end <= offset) {
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.link = encodings.bytes.decode(buf, offset)
        offset += encodings.bytes.decode.bytes
        break
        case 2:
        obj.comment = encodings.string.decode(buf, offset)
        offset += encodings.string.decode.bytes
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defined (val) {
  return val !== null && val !== undefined && (typeof val !== 'number' || !isNaN(val))
}
